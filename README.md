
# What's the point of this project?

This project was made for knowledge purpouse only, it contains a loader that maps a driver, and injects a dll into a target process

![file](https://github.com/pedro-nuness/KernelMapper-Loader/assets/93084039/3ef58df9-1614-4761-b11f-8b08822f9972)

# How it works? 

It contais a loader that run's keyauth's api, as soon as you log-in, the loader automaticaly downloads a target where the dll of the cheat is injected via manual map (there's a communication between the loader and the target via json).


### Initialization and Setup
The process begins with the Init method, which sets up the loader's environment. This method initializes various components, clears unnecessary files, and prepares the target application. It takes an address parameter, which is cast to an API pointer used throughout the loader. It also logs progress at various stages for debugging purposes.

### Clearing
This step clears any existing applications that might interfere with the loader's operations. It iterates through files in the current directory and removes any executable files with specific characteristics to ensure a clean environment.

### Verifying and Starting the Driver
Ensures the required driver is running. If the driver is not running, it attempts to start it by:

1. Killing any conflicting processes.
2. Downloading the driver file from the API.
3. Mapping the driver into memory and verifying its status.
4. If any step fails, it logs an error and stops the loader.

### Creating the Target 
Creates the target executable by downloading the file using the provided TargetID. It saves the downloaded bytes to a file with a unique name generated by combining a base name with a random word.

### Checking the Hash
Verifies the hash of the target executable to ensure it matches the expected authentic hash. If the hash is invalid, it bans the user through the API and logs the error, terminating the loader.

### Creating JSON File
Generates a JSON file containing necessary information for the loader and writes it to the communication folder. This JSON includes details such as the random folder name, loader process ID, user credentials, and the response ID.

### Injection Process
The Injection method starts the actual injection process. It begins by setting a destroy flag and putting the thread to sleep briefly. It then tries to obtain the process ID of the target executable.<br />

The loader waits for a response file to appear in the communication folder. Once the response file is detected, it verifies the safety of the session by checking certain conditions and ensuring the build file is correctly downloaded.<br />


After verifying the session, the loader proceeds to inject the bytes of the build file into the target process. It logs the success or failure of the injection and cleans up any remaining data. <br />

### Idle Monitoring

The Idle method runs in an infinite loop, continuously monitoring the state of the target process and the environment. It performs the following checks:

1. Ensures the target process is running and has the correct process ID.
2. Verifies the hash of the target executable to detect any unauthorized changes.
3. Monitors for any unauthorized processes running on the system.
4. Checks if a debugger is present and bans the user if detected.
4. If any condition fails, the loader logs an error, bans the user if necessary, and terminates the session.

# References

- <a href="https://github.com/stbrumme/hash-library/">Hash library</a><br />
- <a href="https://github.com/KeyAuth/keyauth-cpp-library">KeyAuth cpp library</a> <br />
- <a href="https://github.com/TheCruZ/kdmapper">Kdmapper</a> <br />
- <a href="https://github.com/ocornut/imgui">Dear ImGui </a>
